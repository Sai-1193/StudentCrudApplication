package main

import (
	"encoding/json"
	"fmt"
	"os"
	"strings"
	"text/template"

	"github.com/go-resty/resty/v2"
)

// PostmanItem represents an item in the Postman Collection
type PostmanItem struct {
	Name    string `json:"name"`
	Request struct {
		Method string `json:"method"`
		URL    struct {
			Raw      string   `json:"raw"`
			Protocol string   `json:"protocol"`
			Host     []string `json:"host"`
			Path     []string `json:"path"`
		} `json:"url"`
		// Add other request details as needed
	} `json:"request"`
	// Add other item details as needed
}

// PostmanCollection represents a Postman Collection
type PostmanCollection struct {
	Info struct {
		Name string `json:"name"`
		// Add other collection info as needed
	} `json:"info"`
	Item []PostmanItem `json:"item"`
}

// HTTPClient is a wrapper around go-resty's RestClient
type HTTPClient struct {
	client *resty.Client
}

// NewHTTPClient creates a new HTTPClient instance
func NewHTTPClient() *HTTPClient {
	return &HTTPClient{
		client: resty.New(),
	}
}

// PerformRequest performs an HTTP request and returns the status code and response body
func (h *HTTPClient) PerformRequest(method, url string) (int, string, error) {
	var resp *resty.Response
	var err error

	switch strings.ToUpper(method) {
	case "GET":
		resp, err = h.client.R().Get(url)
	case "POST":
		resp, err = h.client.R().Post(url)
	case "PUT":
		resp, err = h.client.R().Put(url)
	case "DELETE":
		resp, err = h.client.R().Delete(url)
	default:
		return 0, "", fmt.Errorf("unsupported HTTP method: %s", method)
	}

	if err != nil {
		return 0, "", err
	}

	return resp.StatusCode(), resp.String(), nil
}

// CollectionHandler handles parsing, request execution, and HTML writing for a Postman Collection
type CollectionHandler struct {
	Collection *PostmanCollection
	HTTPClient  *HTTPClient
}

// NewCollectionHandler creates a new CollectionHandler instance
func NewCollectionHandler(collection *PostmanCollection, httpClient *HTTPClient) *CollectionHandler {
	return &CollectionHandler{
		Collection: collection,
		HTTPClient: httpClient,
	}
}

// ExecuteRequests performs requests for each item in the collection
func (ch *CollectionHandler) ExecuteRequests() (map[string]int, map[string]string) {
	statusCodes := make(map[string]int)
	responses := make(map[string]string)

	for _, item := range ch.Collection.Item {
		fmt.Printf("Performing request for item: %s\n", item.Name)
		statusCode, response, err := ch.HTTPClient.PerformRequest(item.Request.Method, item.Request.URL.Raw)
		if err != nil {
			fmt.Printf("Error performing request for %s: %v\n", item.Name, err)
			statusCode = 0 // Use 0 as an indicator of error
		}
		statusCodes[item.Name] = statusCode
		responses[item.Name] = response
	}

	return statusCodes, responses
}

// HTMLWriter writes the responses and status codes to a text file
type HTMLWriter struct {
	FileName string
}

// Write writes the responses and status codes to an HTML file
func (hw *HTMLWriter) Write(collectionName string, responses map[string]string, statusCodes map[string]int) {
	file, err := os.Create(hw.FileName)
	if err != nil {
		fmt.Println("Error creating", hw.FileName, ":", err)
		return
	}
	defer file.Close()

	tmpl := `
{{.CollectionName}}
=================

Request Name    | Status Code   | Response Body
----------------|---------------|---------------
{{range $name, $statusCode := .StatusCodes}}
{{printf "%-15s | %-13d | %-s" $name $statusCode (index $.Responses $name)}}
{{end}}
	`

	tmplData := struct {
		CollectionName string
		Responses      map[string]string
		StatusCodes    map[string]int
	}{
		CollectionName: collectionName,
		Responses:      responses,
		StatusCodes:    statusCodes,
	}

	tmplObj := template.Must(template.New("text").Parse(tmpl))
	if err := tmplObj.Execute(file, tmplData); err != nil {
		fmt.Println("Error writing to", hw.FileName, ":", err)
		return
	}

	fmt.Println("Responses written to", hw.FileName)
}

func main() {
	// Replace this with your actual Postman Collection JSON
	postmanCollectionJSON := `
		{
			"info": {
				"name": "Sample Collection"
				// ... other fields
			},
			"item": [
				{
					"name": "Get Request 1",
					"request": {
						"method": "GET",
						"url": {
							"raw": "https://jsonplaceholder.typicode.com/posts/1",
							"protocol": "https",
							"host": ["jsonplaceholder", "typicode", "com"],
							"path": ["posts", "1"]
						}
						// ... other request details
					}
				},
				{
					"name": "Get Request 2",
					"request": {
						"method": "GET",
						"url": {
							"raw": "https://jsonplaceholder.typicode.com/posts/2",
							"protocol": "https",
							"host": ["jsonplaceholder", "typicode", "com"],
							"path": ["posts", "2"]
						}
						// ... other request details
					}
				},
				// ... other requests
			]
		}
	`

	// Parse JSON into PostmanCollection struct
	var collection PostmanCollection
	if err := json.Unmarshal([]byte(postmanCollectionJSON), &collection); err != nil {
		fmt.Println("Error parsing Postman Collection JSON:", err)
		return
	}

	// Create HTTP client
	httpClient := NewHTTPClient()

	// Create CollectionHandler
	collectionHandler := NewCollectionHandler(&collection, httpClient)

	// Execute requests
	statusCodes, responses := collectionHandler.ExecuteRequests()

	// Create HTMLWriter
	htmlWriter := &HTMLWriter{FileName: "output.txt"}

	// Write responses and status codes to HTML
	htmlWriter.Write(collection.Info.Name, responses, statusCodes)
}
