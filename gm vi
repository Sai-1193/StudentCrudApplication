







func main() {
    // Read OpenAPI JSON file
    openAPIJSON, err := ioutil.ReadFile("openapi.json")
    if err != nil {
        log.Fatal(err)
    }

    // Read Postman Collection JSON file
    postmanJSON, err := ioutil.ReadFile("postman_collection.json")
    if err != nil {
        log.Fatal(err)
    }

    // Parse OpenAPI JSON
    var openAPI OpenAPI
    if err := json.Unmarshal(openAPIJSON, &openAPI); err == nil {
        fmt.Println("This is an OpenAPI JSON")
        // You can access OpenAPI specific fields here
        fmt.Println(openAPI.Openapi)
    } else {
        // If parsing fails, try parsing as Postman Collection JSON
        var postman PostmanCollection
        if err := json.Unmarshal(postmanJSON, &postman); err == nil {
            fmt.Println("This is a Postman Collection JSON")
            // You can access Postman Collection specific fields here
            fmt.Println(postman.Info)
        } else {
            fmt.Println("Unknown JSON format")
        }
    }
}




package main

import (
    "encoding/json"
    "fmt"
    "io/ioutil"
)

type OpenAPI struct {
    OpenAPI    string               `json:"openapi"`
    Info       Info                 `json:"info"`
    Servers    []Server             `json:"servers"`
    Paths      map[string]PathItem  `json:"paths"`
    Components Components           `json:"components"`
}

type Info struct {
    Title       string `json:"title"`
    Description string `json:"description"`
    Version     string `json:"version"`
}

type Server struct {
    URL         string `json:"url"`
    Description string `json:"description"`
}

type PathItem struct {
    Get    *Operation `json:"get,omitempty"`
    Post   *Operation `json:"post,omitempty"`
    // Add other HTTP methods as needed
}

type Operation struct {
    Summary    string            `json:"summary"`
    Tags       []string          `json:"tags"`
    RequestBody *RequestBody     `json:"requestBody,omitempty"`
    Responses  map[string]Response `json:"responses"`
}

type RequestBody struct {
    Required bool               `json:"required"`
    Content  map[string]MediaType `json:"content"`
}

type MediaType struct {
    Schema Schema `json:"schema"`
}

type Schema struct {
    Type       string               `json:"type"`
    Properties map[string]Property `json:"properties"`
    Required   []string             `json:"required"`
}

type Property struct {
    Type string `json:"type"`
    // Add other property attributes as needed
}

type Response struct {
    Description string `json:"description"`
    // Add other response attributes as needed
}

type Components struct {
    // Add components like schemas, securitySchemes, etc.
}

func main() {
    // Read the OpenAPI JSON file
    data, err := ioutil.ReadFile("openapi.json")
    if err != nil {
        fmt.Println("Error reading file:", err)
        return
    }

    // Parse the JSON data into the OpenAPI struct
    var openAPI OpenAPI
    if err := json.Unmarshal(data, &openAPI); err != nil {
        fmt.Println("Error parsing JSON:", err)
        return
    }

    // Now you can access the fields of the OpenAPI struct
    fmt.Println("Title:", openAPI.Info.Title)
    fmt.Println("Servers:")
    for _, server := range openAPI.Servers {
        fmt.Println("  URL:", server.URL)
        fmt.Println("  Description:", server.Description)
    }
    fmt.Println("Paths:")
    for path, pathItem := range openAPI.Paths {
        fmt.Println("  Path:", path)
        if pathItem.Get != nil {
            fmt.Println("    GET:")
            fmt.Println("      Summary:", pathItem.Get.Summary)
            fmt.Println("      Tags:", pathItem.Get.Tags)
            if pathItem.Get.RequestBody != nil {
                fmt.Println("      Request Body:")
                fmt.Println("        Required:", pathItem.Get.RequestBody.Required)
                // Add code to handle content and schema
            }
            fmt.Println("      Responses:")
            for code, response := range pathItem.Get.Responses {
                fmt.Println("        Code:", code)
                fmt.Println("          Description:", response.Description)
            }
        }
        if pathItem.Post != nil {
            fmt.Println("    POST:")
            fmt.Println("      Summary:", pathItem.Post.Summary)
            fmt.Println("      Tags:", pathItem.Post.Tags)
            if pathItem.Post.RequestBody != nil {
                fmt.Println("      Request Body:")
                fmt.Println("        Required:", pathItem.Post.RequestBody.Required)
                // Add code to handle content and schema
            }
            fmt.Println("      Responses:")
            for code, response := range pathItem.Post.Responses {
                fmt.Println("        Code:", code)
                fmt.Println("          Description:", response.Description)
            }
        }
        // Add handling for other HTTP methods as needed
    }
}



package main

import (
    "encoding/json"
    "fmt"
    "io/ioutil"
    "github.com/go-resty/resty/v2"
)

type OpenAPI struct {
    OpenAPI    string               `json:"openapi"`
    Info       Info                 `json:"info"`
    Servers    []Server             `json:"servers"`
    Paths      map[string]PathItem  `json:"paths"`
    Components Components           `json:"components"`
}

type Info struct {
    Title       string `json:"title"`
    Description string `json:"description"`
    Version     string `json:"version"`
}

type Server struct {
    URL         string `json:"url"`
    Description string `json:"description"`
}

type PathItem struct {
    Get    *Operation `json:"get,omitempty"`
    Post   *Operation `json:"post,omitempty"`
}

type Operation struct {
    Summary    string            `json:"summary"`
    Tags       []string          `json:"tags"`
    RequestBody *RequestBody     `json:"requestBody,omitempty"`
    Responses  map[string]Response `json:"responses"`
}

type RequestBody struct {
    Required bool               `json:"required"`
    Content  map[string]MediaType `json:"content"`
}

type MediaType struct {
    Schema Schema `json:"schema"`
}

type Schema struct {
    Type       string               `json:"type"`
    Properties map[string]Property `json:"properties"`
    Required   []string             `json:"required"`
}

type Property struct {
    Type string `json:"type"`
}

type Response struct {
    Description string `json:"description"`
}

type Components struct {
    // Add components like schemas, securitySchemes, etc.
}

func main() {
    // Read the OpenAPI JSON file
    data, err := ioutil.ReadFile("openapi.json")
    if err != nil {
        fmt.Println("Error reading file:", err)
        return
    }

    // Parse the JSON data into the OpenAPI struct
    var openAPI OpenAPI
    if err := json.Unmarshal(data, &openAPI); err != nil {
        fmt.Println("Error parsing JSON:", err)
        return
    }

    // Initialize Resty client
    client := resty.New()

    // Perform GET request
    fmt.Println("GET request:")
    resp, err := client.R().Get(openAPI.Servers[0].URL + "/users")
    if err != nil {
        fmt.Println("Error making GET request:", err)
        return
    }
    fmt.Println("Response:", resp.String())

    // Perform POST request
    fmt.Println("POST request:")

    // Extracting the request body schema
    requestBodySchema := openAPI.Paths["/users"].Post.RequestBody.Content["application/json"].Schema

    // Constructing the request body based on the schema
    requestBody := make(map[string]interface{})
    for key, value := range requestBodySchema.Properties {
        // You can customize this part based on the type and format of each property
        // Here, we're assuming all properties are strings
        requestBody[key] = "example_value"
    }

    resp, err = client.R().
        SetHeader("Content-Type", "application/json").
        SetBody(requestBody).
        Post(openAPI.Servers[0].URL + "/users")
    if err != nil {
        fmt.Println("Error making POST request:", err)
        return
    }
    fmt.Println("Response:", resp.String())
}




package main

import (
    "encoding/json"
    "fmt"
    "io/ioutil"
    "github.com/go-resty/resty/v2"
)

type OpenAPI struct {
    Info struct {
        Title       string `json:"title"`
        Description string `json:"description"`
        Version     string `json:"version"`
    } `json:"info"`
    Servers []struct {
        URL         string `json:"url"`
        Description string `json:"description"`
    } `json:"servers"`
    Tags []struct {
        Name        string `json:"name"`
        Description string `json:"description"`
    } `json:"tags"`
    Paths map[string]struct {
        Get struct {
            Summary    string `json:"summary"`
            Tags       []string `json:"tags"`
            Responses  map[string]struct {
                Description string `json:"description"`
            } `json:"responses"`
        } `json:"get"`
        Post struct {
            Summary    string `json:"summary"`
            Tags       []string `json:"tags"`
            RequestBody struct {
                Required bool `json:"required"`
                Content  map[string]struct {
                    Schema struct {
                        Type       string `json:"type"`
                        Properties struct {
                            Username struct {
                                Type string `json:"type"`
                            } `json:"username"`
                            Email struct {
                                Type   string `json:"type"`
                                Format string `json:"format"`
                            } `json:"email"`
                        } `json:"properties"`
                        Required []string `json:"required"`
                    } `json:"schema"`
                } `json:"content"`
            } `json:"requestBody"`
            Responses  map[string]struct {
                Description string `json:"description"`
            } `json:"responses"`
        } `json:"post"`
    } `json:"paths"`
}

func main() {
    // Read the OpenAPI JSON file
    data, err := ioutil.ReadFile("openapi.json")
    if err != nil {
        fmt.Println("Error reading file:", err)
        return
    }

    // Parse the JSON data into the OpenAPI struct
    var openAPI OpenAPI
    if err := json.Unmarshal(data, &openAPI); err != nil {
        fmt.Println("Error parsing JSON:", err)
        return
    }

    // Initialize Resty client
    client := resty.New()

    // Perform GET request
    fmt.Println("GET request:")
    resp, err := client.R().Get(openAPI.Servers[0].URL + "/users")
    if err != nil {
        fmt.Println("Error making GET request:", err)
        return
    }
    fmt.Println("Response:", resp.String())

    // Perform POST request
    fmt.Println("POST request:")
    requestBody := map[string]string{
        "username": "example_user",
        "email":    "user@example.com",
    }
    resp, err = client.R().
        SetHeader("Content-Type", "application/json").
        SetBody(requestBody).
        Post(openAPI.Servers[0].URL + "/users")
    if err != nil {
        fmt.Println("Error making POST request:", err)
        return
    }
    fmt.Println("Response:", resp.String())
}


func extractTags(openAPI OpenAPI, path string) []string {
	tags := []string{}

	// Check if the path exists in the OpenAPI document
	if details, ok := openAPI.Paths[path]; ok {
		// Check if tags are defined for the path
		if tagsSlice, ok := details["tags"]; ok {
			for _, tag := range tagsSlice.([]interface{}) {
				if tagName, ok := tag.(string); ok {
					tags = append(tags, tagName)
				}
			}
		}
	}

	return tags
}


func postRequest(client *resty.Client, openAPI OpenAPI, path string) {
	// Check if the path exists in the OpenAPI document
	if details, ok := openAPI.Paths[path]; ok {
		// Check if the POST method is defined for the path
		if methodDetails, ok := details["post"]; ok {
			// Extract tags if defined for the path
			tags := extractTags(openAPI, path)
			// Find the corresponding server description for the first tag in the path
			serverDescription := findServerDescription(openAPI, tags)

			// Extract headers if defined
			headers := extractHeaders(openAPI, path, "post")
			// Extract request body if defined
			requestBody := extractRequestBody(openAPI, path, "post")
			// Construct URL based on the selected server description
			url := constructURL(openAPI, path, serverDescription)

			// Extract authentication details
			auth := extractAuth(openAPI, path, "post")

			fmt.Printf("Sending POST request to %s\n", url)

			// Create request
			req := client.R().
				SetHeaders(headers).
				SetBody(requestBody)

			// Add authentication if available
			if auth != "" {
				req = req.SetHeader("Authorization", auth)
			}

			// Send request
			resp, err := req.Post(url)
			if err != nil {
				log.Fatalf("Error sending POST request: %s", err)
			}

			fmt.Println("Response:", resp)
		} else {
			fmt.Printf("POST method not defined for path: %s\n", path)
		}
	} else {
		fmt.Printf("Path not found: %s\n", path)
	}
}

// extractAuth extracts authentication details from OpenAPI JSON
func extractAuth(openAPI OpenAPI, path, method string) string {
	// Check if the path exists in the OpenAPI document
	if details, ok := openAPI.Paths[path]; ok {
		// Check if the method exists for the path
		if methodDetails, ok := details[method]; ok {
			// Check if there are security schemes defined for the method
			if security, ok := methodDetails.(map[string]interface{})["security"]; ok {
				// Iterate over security schemes
				for _, scheme := range security.([]interface{}) {
					schemeMap := scheme.(map[string]interface{})
					// Check if it's a basic authentication scheme
					if _, ok := schemeMap["basic"]; ok {
						// Handle basic authentication
						return "Basic <base64-encoded-username-password>"
					}
					// Check if it's a bearer token authentication scheme
					if _, ok := schemeMap["bearer"]; ok {
						// Handle bearer token authentication
						return "Bearer <token>"
					}
				}
			}
		}
	}
	return "" // No authentication found
}


func putRequest(client *resty.Client, openAPI OpenAPI, path string) {
	// Check if the path exists in the OpenAPI document
	if details, ok := openAPI.Paths[path]; ok {
		// Check if the PUT method is defined for the path
		if methodDetails, ok := details["put"]; ok {
			// Extract tags if defined for the path
			tags := extractTags(openAPI, path)
			// Find the corresponding server description for the first tag in the path
			serverDescription := findServerDescription(openAPI, tags)

			// Extract headers if defined
			headers := extractHeaders(openAPI, path, "put")
			// Extract request body if defined
			requestBody := extractRequestBody(openAPI, path, "put")
			// Construct URL based on the selected server description
			url := constructURL(openAPI, path, serverDescription)

			// Extract authentication details
			auth := extractAuth(openAPI, path, "put")

			fmt.Printf("Sending PUT request to %s\n", url)

			// Create request
			req := client.R().
				SetHeaders(headers).
				SetBody(requestBody)

			// Add authentication if available
			if auth != "" {
				req = req.SetHeader("Authorization", auth)
			}

			// Send request
			resp, err := req.Put(url)
			if err != nil {
				log.Fatalf("Error sending PUT request: %s", err)
			}

			fmt.Println("Response:", resp)
		} else {
			fmt.Printf("PUT method not defined for path: %s\n", path)
		}
	} else {
		fmt.Printf("Path not found: %s\n", path)
	}
}

func deleteRequest(client *resty.Client, openAPI OpenAPI, path string) {
	// Check if the path exists in the OpenAPI document
	if details, ok := openAPI.Paths[path]; ok {
		// Check if the DELETE method is defined for the path
		if methodDetails, ok := details["delete"]; ok {
			// Extract tags if defined for the path
			tags := extractTags(openAPI, path)
			// Find the corresponding server description for the first tag in the path
			serverDescription := findServerDescription(openAPI, tags)

			// Construct URL based on the selected server description
			url := constructURL(openAPI, path, serverDescription)

			// Extract authentication details
			auth := extractAuth(openAPI, path, "delete")

			fmt.Printf("Sending DELETE request to %s\n", url)

			// Create request
			req := client.R()

			// Add authentication if available
			if auth != "" {
				req = req.SetHeader("Authorization", auth)
			}

			// Send request
			resp, err := req.Delete(url)
			if err != nil {
				log.Fatalf("Error sending DELETE request: %s", err)
			}

			fmt.Println("Response:", resp)
		} else {
			fmt.Printf("DELETE method not defined for path: %s\n", path)
		}
	} else {
		fmt.Printf("Path not found: %s\n", path)
	}
}




func extractRequestBody(openAPI OpenAPI, path, method string) interface{} {
	// Check if the path exists in the OpenAPI document
	if details, ok := openAPI.Paths[path]; ok {
		// Check if the method exists for the path
		if methodDetails, ok := details[method]; ok {
			// Check if the request body is defined
			if requestBody, ok := methodDetails.RequestBody; ok {
				// Extract the content type
				if content, ok := requestBody.Content["application/json"]; ok {
					// Extract the schema
					schema := content.Schema
					// For simplicity, assuming only JSON content type
					return generateRequestBody(schema)
				}
			}
		}
	}
	return nil // No request body found
}

func generateRequestBody(schema Schema) interface{} {
	// Check the type of schema
	switch schema.Type {
	case "object":
		// Generate a sample object based on the schema properties
		body := make(map[string]interface{})
		for propName, prop := range schema.Properties {
			body[propName] = generateProperty(prop)
		}
		return body
	case "array":
		// Generate a sample array based on the schema items
		items := schema.Items
		return []interface{}{generateProperty(items)}
	default:
		// Unsupported schema type
		return nil
	}
}

func generateProperty(prop Property) interface{} {
	// Check the type of property
	switch prop.Type {
	case "string":
		return "example_string"
	case "integer":
		return 123
	case "number":
		return 123.45
	case "boolean":
		return true
	default:
		return nil
	}
}



